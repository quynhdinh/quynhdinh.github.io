---
layout: post
title: "The block-of-64 trick"
---

Consider this problem: Given a DAG of `N` nodes and `M` edges where `N` could be up to `10^5`, there are `Q` queries, each query are two nodes `u` and `v`, you need to check if `v` is reachable from `u`.
The naive solution is to run a DFS or BFS for each query, which will take `O(N + M)` time per query, where `M` is the number of edges. This can lead to a total time complexity of `O(Q * (N + M))`, which is not efficient for large inputs. Another approach is to using dp with bitset where `dp[i]` store a bitset of size `N` indicating which nodes are reachable from node `i`. To build `dp`, you can use Kahn's algorithm.
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 5000; 
int32_t main(){
  ios::sync_with_stdio(false);
  cin.tie(0);
  int n, m; cin>>n>>m;
  vector<vector<int>> g(n);
  vector<int> in_degree(n);
  for(int i = 0; i < m; i++){
    int u, v; cin>>u>>v;
    g[v].push_back(u);  // reverse the graph
    in_degree[u]++;
  }
  queue<int> q;
  vector<bitset<MAX_N>> dp(n);
  for(int i = 0; i < n; i++){
    if(in_degree[i] == 0)
      q.push(i);
    dp[i][i] = 1;  // each node can reach itself
  }
  while(!empty(q)){
    int u = q.front(); q.pop();
    for(int v : g[u]){
      dp[v] |= dp[u];  // Update dp[v] with reachability from u
      in_degree[v]--;
      if(in_degree[v] == 0){
        q.push(v);
      }
    }
  }
  int Q; cin>>Q;
  while(Q--){
    int u, v; cin>>u>>v;
    cout<<(dp[u][v] ? "YES\n" : "NO\n");
  }
  return 0;
}
```

The operations on bitsets are very efficient. The time complexity of the `or` operation on two bitsets of size `N` is `O(N / 32)` or `O(N / 64)` depending on the architecture, which is much faster than iterating through all nodes. The overall time complexity for building the `dp` table using this method is `O(N^2 / 64 + M)` and then you can answer each query in `O(1)` time. This might work with generous time limits, but this method raises another problem: the size of `dp` could be too large for large `N`. If `N = 100000`, you need `N^2` bits which could lead to memory issues.(1)

Instead of using a bitset of size `N` for each node, you can use `N / 64` numbers of 64 bit integers.
```cpp
#include <bits/stdc++.h>
using namespace std;

int32_t main(){
  int n, m; cin>>n>>m;
  vector<vector<int>> g(n);
  vector<int> in_degree(n);
  for(int i = 0; i < m; i++){
    int u, v; cin>>u>>v;
    g[v].push_back(u);  // reverse the graph
    in_degree[u]++;
  }
  queue<int> q;
  int blocks = n / 64 + (n % 64 != 0);
  vector<vector<uint64_t>> dp(n, vector<uint64_t>(blocks));
  for(int i = 0; i < n; i++){
    if(in_degree[i] == 0)
      q.push(i);
    dp[i][i / 64] |= (1ULL << (i % 64));  // mark self-reachability
  }
  while(!empty(q)){
    int u = q.front(); q.pop();
    for(int v : g[u]){
      // Update dp[v] with reachability from u
      for(int i = 0; i < blocks; i++){
        dp[v][i] |= dp[u][i];
      }
      in_degree[v]--;
      if(in_degree[v] == 0){
        q.push(v);
      }
    }
  }
  int Q; cin>>Q;
  while(Q--){
    int u, v; cin>>u>>v;
    if(dp[u][v / 64] & (1ULL << (v % 64))) {
      cout << "YES\n";
    } else {
      cout << "NO\n";
    }
  }
  return 0;
}
```
The time complexity for building the `dp` table using this method is `O(N * 64 + M)` and then you can answer each query in `O(1)` time. This method is much more memory efficient because instead of using `N^2` bits, you are using `N * (N / 64)` bits which is `N^2 / 64` bits. This can significantly reduce the memory usage and make it feasible to handle larger graphs.
Note:
(1) We are using 10^5 bitsets of size 10^5 which takes 10^10 bits = 1.25GB of memory.
(2) For `dp` array, we are using 10^5 * (10^5 / 64) * 8 bytes = 125MB of memory.